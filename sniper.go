package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"os/signal"
	"regexp"
	"strconv"
	"strings"
	"syscall"
	"time"

	"github.com/bwmarrin/discordgo"
	"github.com/fatih/color"
	"github.com/valyala/fasthttp"
)

var (
	TokenA            string
	TokenB            string
	userID            string
	re                = regexp.MustCompile("(discord.com/gifts/|discordapp.com/gifts/|discord.gift/)([a-zA-Z0-9]+)")
	_                 = regexp.MustCompile("https://privnote.com/.*")
	reGiveaway        = regexp.MustCompile("You won the \\*\\*(.*)\\*\\*")
	reGiveawayMessage = regexp.MustCompile("<https://discordapp.com/channels/(.*)/(.*)/(.*)>")
	magenta           = color.New(color.FgMagenta)
	green             = color.New(color.FgGreen)
	yellow            = color.New(color.FgYellow)
	red               = color.New(color.FgRed)
	cyan              = color.New(color.FgCyan)
	strPost           = []byte("POST")
	_                 = []byte("GET")
)

func init() {
	file, err := ioutil.ReadFile("token.json")
	if err != nil {
		_, _ = fmt.Fprintf(os.Stderr, "Failed read file: %s\n", err)
		os.Exit(1)
	}

	var f interface{}
	err = json.Unmarshal(file, &f)
	if err != nil {
		_, _ = fmt.Fprintf(os.Stderr, "Failed to parse JSON: %s\n", err)
		os.Exit(1)
	}

	m := f.(map[string]interface{})

	str1 := fmt.Sprintf("%v", m["token1"])
	flag.StringVar(&TokenA, "t1", str1, "Token")
	flag.Parse()

	str2 := fmt.Sprintf("%v", m["token2"])
	flag.StringVar(&TokenB, "t2", str2, "Token")
	flag.Parse()
}

func main() {
	c := exec.Command("clear")

	c.Stdout = os.Stdout
	_ = c.Run()
	color.Red(`
‚ñì‚ñà‚ñà‚ñà‚ñà‚ñà‚ñÑ  ‚ñà‚ñà‚ñì  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñÑ‚ñà‚ñà‚ñà‚ñà‚ñÑ   ‚ñí‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñÄ‚ñà‚ñà‚ñà  ‚ñì‚ñà‚ñà‚ñà‚ñà‚ñà‚ñÑ      ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñÑ    ‚ñà  ‚ñà‚ñà‚ñì ‚ñà‚ñà‚ñì‚ñà‚ñà‚ñà  ‚ñì‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñÄ‚ñà‚ñà‚ñà
‚ñí‚ñà‚ñà‚ñÄ ‚ñà‚ñà‚ñå‚ñì‚ñà‚ñà‚ñí‚ñí‚ñà‚ñà    ‚ñí ‚ñí‚ñà‚ñà‚ñÄ ‚ñÄ‚ñà  ‚ñí‚ñà‚ñà‚ñí  ‚ñà‚ñà‚ñí‚ñì‚ñà‚ñà ‚ñí ‚ñà‚ñà‚ñí‚ñí‚ñà‚ñà‚ñÄ ‚ñà‚ñà‚ñå   ‚ñí‚ñà‚ñà    ‚ñí  ‚ñà‚ñà ‚ñÄ‚ñà   ‚ñà ‚ñì‚ñà‚ñà‚ñí‚ñì‚ñà‚ñà‚ñë  ‚ñà‚ñà‚ñí‚ñì‚ñà   ‚ñÄ ‚ñì‚ñà‚ñà ‚ñí ‚ñà‚ñà‚ñí
‚ñë‚ñà‚ñà   ‚ñà‚ñå‚ñí‚ñà‚ñà‚ñí‚ñë ‚ñì‚ñà‚ñà‚ñÑ   ‚ñí‚ñì‚ñà    ‚ñÑ ‚ñí‚ñà‚ñà‚ñë  ‚ñà‚ñà‚ñí‚ñì‚ñà‚ñà ‚ñë‚ñÑ‚ñà ‚ñí‚ñë‚ñà‚ñà   ‚ñà‚ñå   ‚ñë ‚ñì‚ñà‚ñà‚ñÑ   ‚ñì‚ñà‚ñà  ‚ñÄ‚ñà ‚ñà‚ñà‚ñí‚ñí‚ñà‚ñà‚ñí‚ñì‚ñà‚ñà‚ñë ‚ñà‚ñà‚ñì‚ñí‚ñí‚ñà‚ñà‚ñà   ‚ñì‚ñà‚ñà ‚ñë‚ñÑ‚ñà ‚ñí
‚ñë‚ñì‚ñà‚ñÑ   ‚ñå‚ñë‚ñà‚ñà‚ñë  ‚ñí   ‚ñà‚ñà‚ñí‚ñí‚ñì‚ñì‚ñÑ ‚ñÑ‚ñà‚ñà‚ñí‚ñí‚ñà‚ñà   ‚ñà‚ñà‚ñë‚ñí‚ñà‚ñà‚ñÄ‚ñÄ‚ñà‚ñÑ  ‚ñë‚ñì‚ñà‚ñÑ   ‚ñå     ‚ñí   ‚ñà‚ñà‚ñí‚ñì‚ñà‚ñà‚ñí  ‚ñê‚ñå‚ñà‚ñà‚ñí‚ñë‚ñà‚ñà‚ñë‚ñí‚ñà‚ñà‚ñÑ‚ñà‚ñì‚ñí ‚ñí‚ñí‚ñì‚ñà  ‚ñÑ ‚ñí‚ñà‚ñà‚ñÄ‚ñÄ‚ñà‚ñÑ
‚ñë‚ñí‚ñà‚ñà‚ñà‚ñà‚ñì ‚ñë‚ñà‚ñà‚ñë‚ñí‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí‚ñí ‚ñì‚ñà‚ñà‚ñà‚ñÄ ‚ñë‚ñë ‚ñà‚ñà‚ñà‚ñà‚ñì‚ñí‚ñë‚ñë‚ñà‚ñà‚ñì ‚ñí‚ñà‚ñà‚ñí‚ñë‚ñí‚ñà‚ñà‚ñà‚ñà‚ñì    ‚ñí‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí‚ñí‚ñà‚ñà‚ñë   ‚ñì‚ñà‚ñà‚ñë‚ñë‚ñà‚ñà‚ñë‚ñí‚ñà‚ñà‚ñí ‚ñë  ‚ñë‚ñë‚ñí‚ñà‚ñà‚ñà‚ñà‚ñí‚ñë‚ñà‚ñà‚ñì ‚ñí‚ñà‚ñà‚ñí
‚ñí‚ñí‚ñì  ‚ñí ‚ñë‚ñì  ‚ñí ‚ñí‚ñì‚ñí ‚ñí ‚ñë‚ñë ‚ñë‚ñí ‚ñí  ‚ñë‚ñë ‚ñí‚ñë‚ñí‚ñë‚ñí‚ñë ‚ñë ‚ñí‚ñì ‚ñë‚ñí‚ñì‚ñë ‚ñí‚ñí‚ñì  ‚ñí    ‚ñí ‚ñí‚ñì‚ñí ‚ñí ‚ñë‚ñë ‚ñí‚ñë   ‚ñí ‚ñí ‚ñë‚ñì  ‚ñí‚ñì‚ñí‚ñë ‚ñë  ‚ñë‚ñë‚ñë ‚ñí‚ñë ‚ñë‚ñë ‚ñí‚ñì ‚ñë‚ñí‚ñì‚ñë
‚ñë ‚ñí  ‚ñí  ‚ñí ‚ñë‚ñë ‚ñë‚ñí  ‚ñë ‚ñë  ‚ñë  ‚ñí     ‚ñë ‚ñí ‚ñí‚ñë   ‚ñë‚ñí ‚ñë ‚ñí‚ñë ‚ñë ‚ñí  ‚ñí    ‚ñë ‚ñë‚ñí  ‚ñë ‚ñë‚ñë ‚ñë‚ñë   ‚ñë ‚ñí‚ñë ‚ñí ‚ñë‚ñë‚ñí ‚ñë      ‚ñë ‚ñë  ‚ñë  ‚ñë‚ñí ‚ñë ‚ñí‚ñë
‚ñë ‚ñë  ‚ñë  ‚ñí ‚ñë‚ñë  ‚ñë  ‚ñë  ‚ñë        ‚ñë ‚ñë ‚ñë ‚ñí    ‚ñë‚ñë   ‚ñë  ‚ñë ‚ñë  ‚ñë    ‚ñë  ‚ñë  ‚ñë     ‚ñë   ‚ñë ‚ñë  ‚ñí ‚ñë‚ñë‚ñë          ‚ñë     ‚ñë‚ñë   ‚ñë
‚ñë     ‚ñë        ‚ñë  ‚ñë ‚ñë          ‚ñë ‚ñë     ‚ñë        ‚ñë             ‚ñë           ‚ñë  ‚ñë              ‚ñë  ‚ñë   ‚ñë
‚ñë                   ‚ñë                           ‚ñë
	`)
	dg, err := discordgo.New(TokenA)
	if err != nil {
		fmt.Println("error creating Discord session,", err)
		return
	}

	dg.AddHandler(messageCreate)

	err = dg.Open()
	if err != nil {
		fmt.Println("error opening connection,", err)
		return
	}

	t := time.Now()
	color.Cyan("Sniping Discord Nitro and Giveaway on " + strconv.Itoa(len(dg.State.Guilds)) + " Servers üî´\n\n")

	_, _ = magenta.Print(t.Format("15:04:05 "))
	fmt.Println("[+] Bot is ready")
	userID = dg.State.User.ID

	sc := make(chan os.Signal, 1)
	signal.Notify(sc, syscall.SIGINT, syscall.SIGTERM, os.Interrupt, os.Kill)
	<-sc

	_ = dg.Close()
}

func checkCode(bodyString string) {
	_, _ = magenta.Print(time.Now().Format("15:04:05 "))
	if strings.Contains(bodyString, "This gift has been redeemed already.") {
		color.Yellow("[-] Code has been already redeemed")
	} else if strings.Contains(bodyString, "nitro") {
		_, _ = green.Println("[+] Code applied")
	} else if strings.Contains(bodyString, "Unknown Gift Code") {
		_, _ = red.Println("[x] Invalid Code")
	} else {
		color.Yellow("[-] Cannot check gift validity")
	}

}

func messageCreate(s *discordgo.Session, m *discordgo.MessageCreate) {

	if re.Match([]byte(m.Content)) {

		code := re.FindStringSubmatch(m.Content)

		if len(code) < 2 {
			return
		}

		if len(code[2]) < 16 {
			_, _ = magenta.Print(time.Now().Format("15:04:05 "))
			_, _ = red.Print("[=] Auto-detected a fake code: ")
			_, _ = red.Print(code[2])
			fmt.Println(" from " + m.Author.String())
			return
		}

		var strRequestURI = []byte("https://discordapp.com/api/v6/entitlements/gift-codes/" + code[2] + "/redeem")
		req := fasthttp.AcquireRequest()
		req.Header.SetContentType("application/json")
		req.Header.Set("authorization", TokenB)
		req.SetBody([]byte(`{"channel_id":` + m.ChannelID + "}"))
		req.Header.SetMethodBytes(strPost)
		req.SetRequestURIBytes(strRequestURI)
		res := fasthttp.AcquireResponse()

		if err := fasthttp.Do(req, res); err != nil {
			panic("handle error")
		}

		fasthttp.ReleaseRequest(req)

		body := res.Body()

		bodyString := string(body)
		fasthttp.ReleaseResponse(res)

		_, _ = magenta.Print(time.Now().Format("15:04:05 "))
		_, _ = green.Print("[-] Sniped code: ")
		_, _ = red.Print(code[2])
		guild, err := s.State.Guild(m.GuildID)
		if err != nil || guild == nil {
			guild, err = s.Guild(m.GuildID)
			if err != nil {
				println()
				checkCode(bodyString)
				return
			}
		}

		channel, err := s.State.Channel(m.ChannelID)
		if err != nil || guild == nil {
			channel, err = s.Channel(m.ChannelID)
			if err != nil {
				println()
				checkCode(bodyString)
				return
			}
		}

		print(" from " + m.Author.String())
		_, _ = magenta.Println(" [" + guild.Name + " > " + channel.Name + "]")
		checkCode(bodyString)

	} else if strings.Contains(strings.ToLower(m.Content), "**giveaway**") || (strings.Contains(strings.ToLower(m.Content), "react with") && strings.Contains(strings.ToLower(m.Content), "giveaway")) {
		if len(m.Embeds) > 0 && m.Embeds[0].Author != nil {
			if !strings.Contains(strings.ToLower(m.Embeds[0].Author.Name), "nitro") {
				return
			}
		} else {
			return
		}
		time.Sleep(time.Second)
		guild, err := s.State.Guild(m.GuildID)
		if err != nil || guild == nil {
			guild, err = s.Guild(m.GuildID)
			if err != nil {
				return
			}
		}

		channel, err := s.State.Channel(m.ChannelID)
		if err != nil || guild == nil {
			channel, err = s.Channel(m.ChannelID)
			if err != nil {
				return
			}
		}
		_, _ = magenta.Print(time.Now().Format("15:04:05 "))
		_, _ = yellow.Print("[-] Enter Giveaway ")
		_, _ = magenta.Println(" [" + guild.Name + " > " + channel.Name + "]")
		_ = s.MessageReactionAdd(m.ChannelID, m.ID, "üéâ")

	} else if (strings.Contains(strings.ToLower(m.Content), "giveaway") || strings.Contains(strings.ToLower(m.Content), "win") || strings.Contains(strings.ToLower(m.Content), "won")) && strings.Contains(m.Content, userID) {
		reGiveawayHost := regexp.MustCompile("Hosted by: <@(.*)>")
		won := reGiveaway.FindStringSubmatch(m.Content)
		giveawayID := reGiveawayMessage.FindStringSubmatch(m.Content)
		guild, err := s.State.Guild(m.GuildID)
		if err != nil || guild == nil {
			guild, err = s.Guild(m.GuildID)
			if err != nil {
				return
			}
		}

		channel, err := s.State.Channel(m.ChannelID)
		if err != nil || guild == nil {
			channel, err = s.Channel(m.ChannelID)
			if err != nil {
				return
			}
		}
		if giveawayID == nil {
			_, _ = magenta.Print(time.Now().Format("15:04:05 "))
			_, _ = green.Print("[+] Won Giveaway")
			if len(won) > 1 {
				_, _ = green.Print(": ")
				_, _ = cyan.Println(won[1])
			}
			_, _ = magenta.Println(" [" + guild.Name + " > " + channel.Name + "]")

			return
		}
		messages, _ := s.ChannelMessages(m.ChannelID, 1, "", "", giveawayID[3])

		_, _ = magenta.Print(time.Now().Format("15:04:05 "))
		_, _ = green.Print("[+] Won Giveaway")
		if len(won) > 1 {
			_, _ = green.Print(": ")
			_, _ = cyan.Print(won[1])
		}
		_, _ = magenta.Println(" [" + guild.Name + " > " + channel.Name + "]")

		giveawayHost := reGiveawayHost.FindStringSubmatch(messages[0].Embeds[0].Description)
		if len(giveawayHost) < 2 {
			return
		}
		hostChannel, err := s.UserChannelCreate(giveawayHost[1])

		if err != nil {
			return
		}
		time.Sleep(time.Second * 9)

		_, err = s.ChannelMessageSend(hostChannel.ID, "Hi, I won a giveaway !")
		if err != nil {
			return
		}

		host, _ := s.User(giveawayHost[1])
		_, _ = magenta.Print(time.Now().Format("15:04:05 "))
		_, _ = green.Print("[+] Sent DM to host: ")
		_, _ = fmt.Println(host.Username + "#" + host.Discriminator)
	}

}
